import { exec } from "child_process";
import { parseString } from "xml2js";
import fs from "fs/promises";
import { promisify } from "util";
import path from "path";
import ApiError from "../utils/ApiError.js";
import ApiResponse from "../utils/ApiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";

const execPromise = promisify(exec);
const tempDir = path.join(process.cwd(), "temp");

// Create temp directory if it doesn't exist
try {
    await fs.mkdir(tempDir, { recursive: true });
} catch (error) {
    console.error("Failed to create temp directory:", error);
}

const VULNERABILITY_CATEGORIES = {
    HIGH: 'High',
    MEDIUM: 'Medium',
    LOW: 'Low'
};

// Advanced vulnerability scanning with multiple NSE scripts
const runAdvancedVulnerabilityScan = async (target) => {
    const outputFile = path.join(tempDir, `advanced_vuln_scan_${Date.now()}.xml`);
    
    // Comprehensive NSE script selection
    const nseScripts = [
        'vuln',                    // Basic vulnerability detection
        'auth',                    // Authentication issues
        'default',                 // Default credentials
        'discovery',               // Service discovery
        'exploit',                 // Known exploits
        'malware',                 // Malware detection
        'ssl-enum-ciphers',        // SSL/TLS vulnerabilities
        'http-sql-injection',      // SQL injection
        'http-csrf',               // CSRF vulnerabilities
        'http-vuln*'               // Known HTTP vulnerabilities
    ].join(',');

    const command = `nmap -sS -sV -p- --script="${nseScripts}" --script-args=vulns.showall -oX "${outputFile}" ${target}`;

    try {
        console.log(`Starting vulnerability scan for target: ${target}`);
        await execPromise(command);
        const xmlData = await fs.readFile(outputFile, "utf8");
        await fs.unlink(outputFile);

        return new Promise((resolve, reject) => {
            parseString(xmlData, (err, result) => err ? reject(err) : resolve(result));
        });
    } catch (error) {
        throw new ApiError(500, `Advanced vulnerability scan failed: ${error.message}`);
    }
};

// Process and categorize vulnerabilities
const processVulnerabilities = (scanResult) => {
    const vulnerabilities = [];
    const hosts = scanResult.nmaprun?.host || [];

    for (const host of hosts) {
        const ip = host.address?.find(addr => addr.$?.addrtype === "ipv4")?.$?.addr;
        if (!ip) continue;

        const ports = host.ports?.[0]?.port || [];
        for (const port of ports) {
            const scripts = port.script || [];
            for (const script of scripts) {
                // Extract vulnerability details
                const vulnDetails = {
                    ip,
                    port: port.$?.portid,
                    service: port.service?.[0]?.$?.name,
                    protocol: port.$?.protocol,
                    state: port.state?.[0]?.$?.state,
                    scriptId: script.$?.id,
                    output: script.$?.output,
                    timestamp: new Date().toISOString()
                };

                // Determine severity
                vulnDetails.severity = determineSeverity(script.$?.output);

                // Generate recommendations
                vulnDetails.recommendations = generateRecommendations(vulnDetails);

                vulnerabilities.push(vulnDetails);
            }
        }
    }

    return vulnerabilities;
};

// Determine vulnerability severity
const determineSeverity = (output = '') => {
    const output_lower = output.toLowerCase();
    
    if (output_lower.includes('critical') || 
        output_lower.includes('high risk') || 
        output_lower.includes('remote code execution')) {
        return VULNERABILITY_CATEGORIES.HIGH;
    }
    
    if (output_lower.includes('medium') || 
        output_lower.includes('moderate') || 
        output_lower.includes('xss')) {
        return VULNERABILITY_CATEGORIES.MEDIUM;
    }
    
    return VULNERABILITY_CATEGORIES.LOW;
};

// Generate security recommendations
const generateRecommendations = (vulnDetails) => {
    const recommendations = [];

    // Service-specific recommendations
    switch (vulnDetails.service) {
        case 'http':
        case 'https':
            recommendations.push(
                'Enable HTTPS and configure proper SSL/TLS',
                'Implement Web Application Firewall (WAF)',
                'Update web server software to latest version'
            );
            break;
        case 'ssh':
            recommendations.push(
                'Disable root login',
                'Use key-based authentication',
                'Implement fail2ban'
            );
            break;
        case 'ftp':
            recommendations.push(
                'Use SFTP instead of FTP',
                'Implement strong authentication',
                'Restrict file permissions'
            );
            break;
        default:
            recommendations.push(
                'Review service necessity',
                'Implement network segmentation',
                'Apply latest security patches'
            );
    }

    // Severity-specific recommendations
    if (vulnDetails.severity === VULNERABILITY_CATEGORIES.HIGH) {
        recommendations.push(
            'Immediate patching required',
            'Consider temporary service disable',
            'Implement additional monitoring'
        );
    }

    return recommendations;
};

// Main vulnerability scan controller
const runVulnerabilityScan = asyncHandler(async (req, res) => {
    const { target } = req.params;
    if (!target) throw new ApiError(400, "Target is required");

    try {
        // Run the advanced scan
        const scanResult = await runAdvancedVulnerabilityScan(target);
        
        // Process results
        const vulnerabilities = processVulnerabilities(scanResult);

        // Group vulnerabilities by severity
        const groupedVulnerabilities = {
            high: vulnerabilities.filter(v => v.severity === VULNERABILITY_CATEGORIES.HIGH),
            medium: vulnerabilities.filter(v => v.severity === VULNERABILITY_CATEGORIES.MEDIUM),
            low: vulnerabilities.filter(v => v.severity === VULNERABILITY_CATEGORIES.LOW)
        };

        return res.status(200).json(
            new ApiResponse(
                200, 
                { 
                    target,
                    vulnerabilities: groupedVulnerabilities,
                    summary: {
                        total: vulnerabilities.length,
                        high: groupedVulnerabilities.high.length,
                        medium: groupedVulnerabilities.medium.length,
                        low: groupedVulnerabilities.low.length
                    }
                },
                "Advanced vulnerability scan completed"
            )
        );

    } catch (error) {
        console.error(`Vulnerability scan failed for target ${target}:`, error);
        throw new ApiError(500, `Vulnerability scan failed: ${error.message}`);
    }
});

export const vulnerabilityScanController = {
    runVulnerabilityScan
}; 